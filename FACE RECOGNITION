import os 
import cv2 
import face_recognition 
import numpy as np 
 
# ========================================== 
# CONFIGURATION 
# ========================================== 
MODEL = "hog"          # "hog" = faster on CPU, "cnn" = more accurate (requires GPU) 
TOLERANCE = 0.45       # Lower = stricter match 
SCALER = 4             # For smaller webcam frames (performance) 
KNOWN_FACES = {}        
 
 
# ========================================== 
# LOAD ALL KNOWN FACES FROM FOLDER STRUCTURE 
# ========================================== 
def load_known_faces(base_dir="known_faces"): 
    """ 
    Loads all face encodings from folders inside base_dir. 
    Each folder name is treated as the person's name. 
    """ 
    known_faces = {} 
    total_images = 0 
 
    if not os.path.exists(base_dir): 
        print(f"[WARNING] Folder '{base_dir}' not found! Create it and add folders for each person.") 
        return known_faces 
 
    print(f"[INFO] Loading faces from '{base_dir}'...") 
                                                                             
 
 
    for person_name in os.listdir(base_dir): 
        person_path = os.path.join(base_dir, person_name) 
        if not os.path.isdir(person_path): 
            continue 
 
        encodings = [] 
        for filename in os.listdir(person_path): 
            if filename.lower().endswith(('.jpg', '.jpeg', '.png')): 
                img_path = os.path.join(person_path, filename) 
                image = face_recognition.load_image_file(img_path) 
                faces = face_recognition.face_encodings(image) 
                if faces: 
                    encodings.append(faces[0]) 
                    total_images += 1 
                else: 
                    print(f"[WARN] No face found in {filename}, skipping...") 
 
        if encodings: 
            known_faces[person_name.lower()] = encodings 
            print(f"[OK] Loaded {len(encodings)} images for {person_name}") 
 
    print(f"[INFO] Total faces loaded: {total_images}") 
    return known_faces 
 
 
# ========================================== 
# DETECT AND RECOGNIZE FACES 
# ========================================== 
def recognize_faces(frame, known_faces): 
    """ 
    Detects faces in the frame and compares with known encodings. 
    Returns: [(top, right, bottom, left, name), ...] 
    """ 
    small_frame = cv2.resize(frame, (0, 0), fx=1 / SCALER, fy=1 / SCALER) 
                                                                            
    rgb_small_frame = cv2.cvtColor(small_frame, cv2.COLOR_BGR2RGB) 
 
    face_locations = face_recognition.face_locations(rgb_small_frame, model=MODEL) 
    face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations) 
 
    recognized_faces = [] 
 
    for face_encoding, face_location in zip(face_encodings, face_locations): 
        matches = [] 
        name = "Unknown" 
 
        for person_name, encodings in known_faces.items(): 
            results = face_recognition.compare_faces(encodings, face_encoding, TOLERANCE) 
            if True in results: 
                matches.append(person_name) 
 
        if matches: 
            # If multiple matches, pick the most frequent 
            name = max(set(matches), key=matches.count) 
 
        # Scale back to original frame size 
        top, right, bottom, left = [v * SCALER for v in face_location] 
        recognized_faces.append((top, right, bottom, left, name)) 
 
    return recognized_faces 
 
 
# ========================================== 
# DRAW BOXES & LABELS 
# ========================================== 
def draw_labels(frame, recognized_faces): 
    for (top, right, bottom, left, name) in recognized_faces: 
        color = (0, 255, 0) if name != "Unknown" else (0, 0, 255) 
        cv2.rectangle(frame, (left, top), (right, bottom), color, 2) 
        cv2.rectangle(frame, (left, bottom - 25), (right, bottom), color, cv2.FILLED) 
                                                                             
 
        cv2.putText(frame, name.upper(), (left + 6, bottom - 6), 
                    cv2.FONT_HERSHEY_DUPLEX, 0.6, (255, 255, 255), 1) 
    return frame 
import cv2 
import tkinter as tk 
from tkinter import messagebox 
from PIL import Image, ImageTk 
import faces_recognizer2 as fr 
 
# ===================================================== 
# INITIAL SETUP 
# ===================================================== 
cap = cv2.VideoCapture(0)  # 0 = laptop webcam, change if needed 
 
# Load all known faces once at startup 
KNOWN_FACES = fr.load_known_faces("known_faces") 
 
# ===================================================== 
# GUI SETUP 
# ===================================================== 
root = tk.Tk() 
root.title("Face Recognition System") 
root.geometry("900x700") 
root.configure(bg="#0A192F") 
 
label = tk.Label(root, text="Real-Time Face Recognition", font=("Arial", 20, "bold"), bg="#0A192F", 
fg="white") 
label.pack(pady=20) 
 
video_label = tk.Label(root, bg="#0A192F") 
video_label.pack(pady=10) 
 
status_label = tk.Label(root, text="Initializing webcam...", font=("Arial", 14), bg="#0A192F", 
fg="#64FFDA") 
status_label.pack(pady=10) 
                                                                          
 
 
running = True 
 
 
# ===================================================== 
# VIDEO LOOP 
# ===================================================== 
def update_frame(): 
    if not running: 
        return 
 
    ret, frame = cap.read() 
    if not ret: 
        status_label.config(text="
âš 
 Unable to access camera") 
        return 
 
    recognized_faces = fr.recognize_faces(frame, KNOWN_FACES) 
    frame = fr.draw_labels(frame, recognized_faces) 
 
    # Update status label 
    detected_names = [name for (_, _, _, _, name) in recognized_faces] 
    if detected_names: 
        status_label.config(text=f"Detected: {', '.join(set(detected_names)).title()}") 
    else: 
        status_label.config(text="No faces detected") 
 
    # Display video on GUI 
    img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) 
    img_pil = Image.fromarray(img_rgb) 
    imgtk = ImageTk.PhotoImage(image=img_pil) 
    video_label.imgtk = imgtk 
    video_label.configure(image=imgtk) 
    video_label.after(10, update_frame) 
 
 
                                                                            33 
 
# ===================================================== 
# CONTROLS 
# ===================================================== 
def on_close(): 
    global running 
    running = False 
    cap.release() 
    cv2.destroyAllWindows() 
    root.destroy() 
 
 
btn_exit = tk.Button(root, text="Exit", command=on_close, bg="#64FFDA", fg="black", 
                     font=("Arial", 14, "bold"), width=10) 
btn_exit.pack(pady=20) 
 
root.protocol("WM_DELETE_WINDOW", on_close) 
update_frame() 
root.mainloop() 
